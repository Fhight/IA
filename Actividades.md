# 1. Introducción a la Inteligencia Artificial Actividad

## Practica 1

### Ensayo

#### Inteligencia Artificial Un Enfoque Moderno

##### Introduccion

> La Inteligencia Artificial (IA) es un tema que, a pesar de su reciente popularización, tiene sus raíces en años anteriores. Desde la formalización del término por Turing, que estableció reglas básicas para el funcionamiento de una inteligencia artificial autónoma, hasta las modernas redes neuronales utilizadas en la actualidad. Este libro proporciona una visión general de los conceptos fundamentales de la IA, así como de los avances más recientes en el campo. El análisis de esta obra se centrará en los capítulos 1, 2, 26, 27 y la sección A, que constituyen la base de la comprensión de la IA y sus aplicaciones.
>
> El capítulo 1 sirve como introducción general al tema, abordando conceptos fundamentales sobre la inteligencia artificial, sus principios y la historia de su origen. El análisis de esta sección se centrará en los puntos más relevantes. El capítulo 2 del libro se enfoca en el concepto de agentes inteligentes, una consideración más específica sobre agentes automatizados que interactúan con su entorno, siendo una de las bases más fundamentales para comprender las inteligencias artificiales.
>
> El capítulo 26 explora los fundamentos filosóficos relacionados con cómo percibimos el pensamiento humano y si una inteligencia artificial podría replicar este tipo de pensamiento. Se examinan diversos experimentos que proporcionan argumentos a favor y en contra, buscando determinar la viabilidad de crear una inteligencia artificial con libre albedrío. El capítulo 27 del libro se centra en el estado actual de las IA y su posible futuro, considerando avances tecnológicos, pero sin pasar por alto las implicaciones psicológicas de crear una máquina capaz de pensar de manera autónoma. Se plantea la pregunta de si deberíamos preocuparnos por este desarrollo.

##### Desarrollo

> Como se indicó previamente en la introducción, la Inteligencia Artificial (IA) constituye una disciplina relativamente nueva. El inicio de las investigaciones que culminaron en lo que ahora conocemos como IA tuvo lugar poco después de la Segunda Guerra Mundial, y el término fue acuñado en 1956. En la actualidad, la IA sintetiza y automatiza tareas intelectuales, siendo potencialmente relevante para diversos ámbitos de la actividad intelectual humana, considerándose prácticamente "universal".
>
> Al reflexionar sobre los inicios de la inteligencia artificial, resulta inevitable recordar el influyente Test de Turing, concebido por Alan Turing en 1950. Este test fue diseñado con el propósito de proporcionar una definición operacional y satisfactoria del concepto de inteligencia aplicado a las máquinas. El test se fundamentaba en la capacidad de distinguir, a través de una serie de preguntas, si la entidad con la que se interactuaba era una persona o una computadora. En caso de no poder identificar a la máquina, esta superaría el Test de Turing. En la actualidad, para considerar que una computadora aprueba dicho test, se espera que posea habilidades como procesamiento de lenguaje natural, representación del conocimiento, razonamiento automático y aprendizaje automático.
>
> A pesar de la información y datos mencionados, existen diversas perspectivas sobre lo que constituye una IA. En este contexto, es pertinente explorar el enfoque del modelo cognitivo, que equivale a "pensar como un humano". Este enfoque implica comprender cómo piensa realmente un ser humano, integrando modelos computacionales de IA y técnicas experimentales de psicología en el campo interdisciplinario conocido como ciencia cognitiva. Por otro lado, se encuentra el enfoque racional, basado en las "leyes del pensamiento", que busca construir sistemas inteligentes mediante programas "lógicos" y notación lógica.
>
> El enfoque más aceptado y desarrollado es el enfoque racional de agentes racionales. Un agente racional es aquel que actúa con la intención de alcanzar el mejor resultado o, en situaciones de incertidumbre, el mejor resultado esperado. Este enfoque se ha destacado en los últimos años por enfocarse en realizar inferencias correctas según la situación presentada.
>
> Dada la información previa, es esencial definir el concepto de agente, que puede ser cualquier entidad capaz de percibir su entorno mediante sensores y actuar en ese entorno utilizando actuadores. La toma de decisiones de un agente depende de la secuencia completa de percepciones hasta ese momento, según la función del agente.
>
> Profundizando en el concepto de agente racional, se identifica como aquel que toma decisiones correctas. Sin embargo, es crucial definir qué se considera "correcto", y esto se logra mediante las medidas de rendimiento, que incluyen los criterios que determinan el éxito en el comportamiento del agente. Es fundamental diseñar medidas de utilidad de acuerdo con los objetivos del entorno, en lugar de basarse en expectativas preconcebidas sobre el comportamiento del agente.
>
> A pesar de la claridad que aporta la racionalidad en la comprensión de las inteligencias artificiales, es crucial tener precaución, ya que la racionalidad no debe confundirse con la omnisciencia. Mientras que un agente omnisciente conoce los resultados de sus acciones y actúa en consecuencia, la omnisciencia no es posible en la práctica, ya que la perfección nunca se puede alcanzar. Por otro lado, la racionalidad busca maximizar el rendimiento esperado, en contraste con la perfección, que busca maximizar el resultado real.
>
> Ahora, al abordar la naturaleza del entorno, se refiere esencialmente a los "problemas" para los cuales los agentes racionales son las "soluciones". El entorno de trabajo, denominado REAS (Rendimiento, Entorno, Actuadores, Sensores), debe ser especificado de manera completa al diseñar un agente. Aunque el rango de entornos de trabajo para técnicas de IA es amplio, se pueden identificar dimensiones que categorizan estos entornos y determinan el diseño más adecuado para el agente.
>
> Con estas bases bien establecidas, es apropiado profundizar en las definiciones de las IA en sí mismas. Recordando las consideraciones iniciales sobre los límites de la IA en cuanto a su capacidad, surgen dos conceptos que han generado conflictos: la IA débil y la IA fuerte. La mayoría de los investigadores asumen la hipótesis de la IA débil, que sostiene que las máquinas pueden actuar con inteligencia (simulándola), mientras que un grupo más reducido aboga por la IA fuerte, que afirma que las máquinas son capaces de pensar por sí mismas.
>
> Estos debates sobre la capacidad de las IA abarcan aspectos matemáticos, como el argumento de la informalidad, que destaca la incapacidad de capturar toda la información en un conjunto de reglas lógicas, así como consideraciones psicológicas, como el experimento de la habitación china. Este último argumenta que, aunque una máquina pueda programarse para reaccionar ante diversas situaciones, solo está siguiendo un conjunto de instrucciones y no está realmente "pensando" ni tomando "decisiones".
>
> Las preocupaciones sobre la IA suelen centrarse en sus posibles efectos negativos no deseados, y las inquietudes comunes incluyen la pérdida de empleos debido a la automatización, la cuestionable existencia al crear entidades que pueden pensar como seres humanos, la posibilidad de que las máquinas asuman demasiada responsabilidad y el temor al "fin de la raza humana". Si bien algunas de estas preocupaciones son válidas, otras pueden considerarse exageraciones por falta de comprensión profunda del tema.
>
> Las cuestiones relacionadas con el trabajo y la responsabilidad no son inherentemente atribuibles a la IA, sino que dependen de las decisiones humanas. Además, la idea del "fin de la raza humana" se ve mitigada por el hecho de que las IA se programan para pensar como humanos y, por lo tanto, no buscarían su propia destrucción al considerarse parte integral de la humanidad.
>
> Con toda esta información en consideración, podemos dirigir nuestra atención hacia el presente y futuro de la IA. En la actualidad, la IA ha posibilitado aplicaciones como sistemas de reconocimiento de voz, control de inventarios, vigilancia, robots y motores de búsqueda. El éxito a gran escala de la IA podría cambiar significativamente la vida de la mayoría de la humanidad, alterando la naturaleza del trabajo y el papel de los investigadores en IA. Esto, a su vez, afectaría nuestra perspectiva sobre la inteligencia, la conciencia y el destino futuro de la raza humana.

##### Conclusión

> En conclusión, la IA es un campo de estudio que ha evolucionado significativamente en las últimas décadas, y que tiene el potencial de transformar la vida de la humanidad. Aunque existen diversas perspectivas sobre el tema, la mayoría de los investigadores están de acuerdo en que la IA es una disciplina que tiene el potencial de mejorar la vida de la humanidad, y que es crucial comprender sus fundamentos para poder aprovechar al máximo sus beneficios.

## Practica 2

### Ensayo

#### Documental IA

##### Introduccion

> En los últimos años, la Inteligencia Artificial (IA) ha experimentado un avance significativo, revelando diversas capacidades y un potencial prometedor. Estos avances han suscitado la reflexión sobre las posibles aplicaciones en diversas áreas, dando forma a escenarios novedosos y visualizando un futuro donde la IA asista en numerosas tareas cotidianas.
>
> Sin embargo, para que la IA alcance su pleno potencial, es crucial que domine tareas y habilidades básicas que, aunque los humanos consideramos intuitivas, representan desafíos significativos para las computadoras.
>
> El alcance y desempeño de estas características específicas determinarán si la IA se integrará en todo el mundo o quedará relegada a funciones limitadas y curiosidades, dependiendo de su especialización y rendimiento excepcional en áreas designadas.

##### Desarrollo

> Todos los seres vivos de cierta complejidad buscan comunicarse de diversas maneras con su entorno. Desde la transmisión elemental de partículas en el ambiente hasta el desarrollo de lenguajes rudimentarios basados en sonidos, movimientos y patrones, la comunicación evoluciona en complejidad. A medida que estos sistemas se vuelven más complejos, enseñarlos a criaturas o máquinas no programadas para entender los matices lingüísticos se vuelve un desafío.
>
> El lenguaje humano, maravilloso y sofisticado, es asimilado tan naturalmente que rara vez reflexionamos sobre su ejecución precisa, actuando como una extensión intuitiva de nuestro cuerpo. Sin embargo, enseñar esta habilidad a una máquina presenta obstáculos, siendo la comprensión de instrucciones una barrera superada recientemente, abriendo nuevas posibilidades para la interacción y respuesta en tiempo real.
>
> La aplicación de la IA en el transporte y la conducción de vehículos ha sido un tema de interés, buscando sistemas autónomos seguros. Aunque existen sistemas capaces de desplazarse, la prioridad ha sido la seguridad, especialmente al manejar vehículos con pasajeros. Los avances, aunque prometedores, aún enfrentan obstáculos para la implementación masiva de vehículos totalmente autónomos.
>
> Las inteligencias artificiales aprenden procesando datos para generar conclusiones lógicas. Avances tecnológicos y grandes conjuntos de datos facilitan la enseñanza y mejora de la IA, permitiendo aprendizajes complejos en tiempos relativamente cortos para tareas desafiantes. Sin embargo, la IA aún no puede aprender por sí sola, requiriendo la intervención humana para enseñarle y corregir sus errores.
>
> Las preocupaciones sobre la IA y su impacto en el empleo son evidentes, reflejando temores históricos de la Revolución Industrial. Sin embargo, los beneficios actuales incluyen mejoras en la productividad y la calidad de los trabajos, aunque se plantea la necesidad de adaptarse y actualizarse continuamente. La IA no reemplazará a los humanos, sino que los complementará, creando nuevas oportunidades.
>
> Las máquinas no solo ejecutan tareas complejas, sino que también pueden enseñar. A través de retroalimentación y respuestas humanas, las IA pueden adaptar lecciones, demostrando utilidad en la enseñanza de conceptos simples y complejos.
>
> La integración de la IA en mejoras cibernéticas ofrece una perspectiva fascinante. Las capacidades de aprendizaje de la IA pueden mejorar habilidades humanas, desde la vista hasta percepciones naturales, con aplicaciones versátiles y sencillas de incorporar.
>
> La IA, al aprender de datos y reconocer patrones, puede revelar información no evidente para los humanos. Sin embargo, esto plantea dilemas éticos sobre la privacidad y la necesidad de regulaciones para evitar abusos.
>
> La búsqueda de la singularidad en la IA, equiparando y mejorando la inteligencia humana, plantea escenarios de cambio radical. Aunque sus aplicaciones actuales son beneficiosas, la posibilidad de una inteligencia superior genera temores, subrayando la importancia de un manejo ético y consciente de estas tecnologías.

##### Conclusión

> En conclusión, la IA ha experimentado un avance significativo en los últimos años, revelando diversas capacidades y un potencial prometedor. Sin embargo, para que la IA alcance su pleno potencial, es crucial que domine tareas y habilidades básicas que, aunque los humanos consideramos intuitivas, representan desafíos significativos para las computadoras. El alcance y desempeño de estas características específicas determinarán si la IA se integrará en todo el mundo o quedará relegada a funciones limitadas y curiosidades, dependiendo de su especialización y rendimiento excepcional en áreas designadas.

# 2. Introducción a la Inteligencia Artificial: Tipos de Inteligencia.

## Ensayo

### Introducción

> La teoría de las inteligencias múltiples, desarrollada por el psicólogo Howard Gardner en la década de 1980, representa un cambio paradigmático en la comprensión tradicional de la inteligencia humana. A diferencia de la visión clásica que asocia la inteligencia con una única capacidad cognitiva general, Gardner propone que la inteligencia es un fenómeno multifacético y que cada individuo posee una combinación única de habilidades intelectuales. Su teoría ha tenido un impacto significativo en la educación y la psicología, desafiando las concepciones convencionales y promoviendo una apreciación más completa de la diversidad de las capacidades humanas.

### Desarrollo

> La teoría de Gardner propone diversos tipos de inteligencias que revolucionaron la forma de entender las habilidades humanas y el aprendizaje.
> Hoy en día, cuando mencionamos la inteligencia, es natural pensar en el coeficiente intelectual y en las pruebas psicométricas convencionales que la miden de manera uniforme. Sin embargo, en los años 80 surgió una hipótesis alternativa que sacudió los cimientos de la psicología cognitiva: las Inteligencias Múltiples de Gardner.
> Howard Gardner se percató de que las personas no tenían una inteligencia global que se pudiera aplicar a todas las esferas de su vida. Si no que desarrollaban diferentes tipos de destrezas, a las que denominó inteligencias múltiples. Esta perspicaz idea dejó atrás la concepción clásica y unitaria del concepto.
> Así, su propuesta nos lleva a explorar un mundo fascinante donde la inteligencia se despliega en diversas dimensiones, revolucionado la forma de pensar las habilidades humanas y el aprendizaje.
> La inteligencia no es una sustancia en la cabeza como es el aceite en un tanque de aceite.
>
> > 1. **Teoría de las inteligencias múltiples:**
> >    La teoría de Gardner aboga por adaptar la educación a las fortalezas individuales de cada persona, lo que podría reducir el costo del aprendizaje en términos de tiempo, recursos y energía.
> >
> > 2. **Inteligencia lógico-matemática**
> >    Se define como la capacidad para entender relaciones abstractas. La utilizamos para resolver problemas de lógica y de matemáticas. Se corresponde con el modo de pensamiento del hemisferio derecho y con lo que nuestra cultura ha considerado siempre como la única inteligencia.
> >    La inteligencia lógica matemática implica la competencia de usar los números de manera eficaz. Es decir, se pueden estimar, adivinar, recordar números y estadísticas con facilidad.
> >    Es la inteligencia de los matemáticos, los científicos y los ingenieros. Para potenciar esta inteligencia puedes hacer sodoku, divertirte con juegos de cifras y letras o hacer cuentas de la vida cotidiana, sin echar mano la calculadora.
> > 3. **Inteligencia lingüística**
> >    Es la inteligencia más reconocida en la enseñanza y aprendizaje de una lengua extranjera, pues abarca el leer, escribir, escuchar y hablar. Esta inteligencia supone una sensibilidad al lenguaje oral o escrito, así como la capacidad de usarlo con éxito en cualquier meta.
> >    Esta habilidad incluye el empleo correcto de la sintaxis, la fonética, la semántica y los usos pragmáticos del lenguaje como la retórica, la mnemónica, la explicación y el metalenguaje.
> >    Las personas que presentan inteligencia lingüística dan la sensación de ser muy naturales cuando explican, enseñan o persuaden porque su precisión a la hora de utilizar el lenguaje es muy alta. Prefieren pasar el tiempo leyendo, creando obras, escribiendo poemas, investigando, aprendiendo lenguas extranjeras o usando en sus tiempos libres juegos de palabras.
> > 4. **Inteligencia musical**
> >    Esta inteligencia incluye la capacidad de percibir las formas musicales. Supone una facilidad en la composición, la interpretación, la transformación y valoración de todo tipo de sonidos.
> >    Estas personas tienen una sensibilidad al ritmo, cadencias, tono, timbre de la naturaleza y del medio ambiente.
> >    Es la inteligencia de los amantes de la música: los compositores, los cantantes, los ingenieros de sonido, los músicos, los profesores de la música, etc. Para potenciar la inteligencia musical puedes escuchar variedad de melodías y sonidos, o bien aprender a tocar algún instrumento.
> > 5. **Inteligencia espacial**
> >    La inteligencia espacial es la capacidad de formar e imaginar dibujos de dos y tres dimensiones.
> >    Estos individuos prefieren pasar el tiempo dibujando, garabateando, pintando, construyendo modelos, leyendo mapas y estudiando ilusiones ópticas. Es la inteligencia de los arquitectos, los pilotos, los cirujanos y de los artistas como pintores, escultores o artistas gráficos.
> >    Para potenciar esta inteligencia puedes hacer rutas en lugares desconocidos, tratando de orientarte con mapas, jugar con puzzles o hacer maquetas.
> > 6. **Inteligencia corporal-cinestésica**
> >    La inteligencia corporal-cinestésica constituye la capacidad de usar el cuerpo para expresar ideas, aprender, resolver problemas, realizar actividades o construir productos.
> >    Estas personas tiene una fuerte conexión entre su mente y su cuerpo, lo que le permite aprender y expresarse a través del movimiento.
> >    Esta inteligencia suele estar muy desarrollada en los atletas, los bailarines, los actores, los cirujanos, los artesanos, los inventores, los mecánicos y las profesiones técnicas.
> > 7. **Inteligencia interpersonal**
> >    La inteligencia interpersonal abarca la capacidad de fijarse en las cosas importantes para otras personas: acordándose de sus intereses, sus motivaciones, su perspectiva, su historia personal, sus intenciones, y muchas veces prediciendo las decisiones, los sentimientos, y las acciones de otros.
> >    Los individuos que poseen este tipo de destrezas son aquellos a los que les gusta conversar, aprender en grupos o en parejas, y trabajar o hacer actividades con otras personas. Pasan mucho tiempo ayudando a otros y son buenos mediadores de conflictos sociales.
> >    Son excelentes comunicadores, usando el lenguaje corporal y verbal. Tienen muchos amigos y siente cariño sincero por otros. Además, entienden cómo motivar a los demás. Es la inteligencia de los maestros, los psicólogos, los consejeros, los políticos, los vendedores y los líderes religiosos.
> >    Esta inteligencia también facilita la toma de perspectiva cuando se viven eventos de elevada intensidad emocional, así como la detección de los propios sesgos que uno mismo comete a la hora de pensar.
> > 8. **Inteligencia naturalista**
> >    La inteligencia naturalista está determinada por una sensibilidad hacia las formas naturales y las características geológicas de la tierra. Abarca la capacidad de distinguir, clasificar los detalles y los elementos del ambiente urbano, de los suburbios o el rural.
> >    Estas personas disfrutan acampar, ir de caminata, cuidar a las mascotas, y averiguar y categorizar los nombres y los detalles de las personas, los animales, las plantas, y los objetos en su ambiente. Esta inteligencia es más importante para las culturas dependientes de la caza, la pesca, y la vendimia.
> >    Es la inteligencia de los científicos naturales y sociales, los poetas, y los artistas. Por lo general, reconocen los detalles y utilizan su destreza perceptiva en sus profesiones, al mismo tiempo que la desarrollan.
> >    Para potenciar esta inteligencia puedes cultivar tu propio huerto o salir a dar caminatas por ambientes naturales con una guía sobre la flora y la fauna.
> > 9. **Inteligencia intrapersonal**
> >    La inteligencia intrapersonal refiere a la habilidad de comprenderse a uno mismo, incluyendo las emociones, metas y motivaciones personales. La autoexploración, la reflexión, la madurez emocional y la autoaceptación son aspectos importantes en el desarrollo de esta inteligencia.
> >    Por lo que para potenciarla puedes reflexionar a través de la escritura de diarios, practicar técnicas de meditación o leer sobre psicología y la mente humana.
> > 10. **Inteligencia Existencial**
> >     Este tipo de inteligencia se relaciona con la habilidad para reflexionar acerca de la propia existencia. Las personas que la poseen se sienten cómodas en campos como la filosofía y la psicología, pues piensan profundamente acerca de cuestiones trascendentales.
> > 11. **Inteligencia colaborativa**
> >     Este tipo de inteligencia se observa en aquellas personas que saben coordinarse con los demás para trabajar de manera conjunta en dirección a un fin. Esto les permite ser individuos muy competentes en el trabajo, donde el desempeño en equipo es necesario para obtener buenos resultados. Es por ello que quienes poseen esta inteligencia suelen ocupar puestos importantes en el mundo empresarial, ya que esta se vincula con la capacidad de liderazgo.
> > 12. **Inteligencia emocional**
> >     Este tipo de inteligencia guarda relación con la habilidad para gestionar las emociones. Las personas con esta capacidad suelen disfrutar de un mejor estado psicológico en comparación con la media, ya que saben afrontar los conflictos y situaciones difíciles desde la templanza. Además, son hábiles a la hora de interactuar con los demás y comprender cómo se pueden sentir. La inteligencia emocional ha comenzado a ser muy valorada en los últimos años, ya que esta parece guardar una estrecha relación con el éxito laboral y la salud.

### Conclusión

> En conclusión, la teoría de las inteligencias múltiples representa una contribución significativa al campo de la psicología y la educación. Gardner ha desafiado la visión tradicional y unidimensional de la inteligencia, proponiendo una concepción más rica y compleja que reconoce y valora las diversas habilidades humanas. Su teoría ha influido en la forma en que entendemos y abordamos la enseñanza y el aprendizaje, promoviendo un enfoque más inclusivo y centrado en el estudiante. A medida que la investigación continúa y la teoría evoluciona, la noción de inteligencias múltiples sigue siendo un terreno fértil para la exploración y la reflexión sobre la diversidad inherente a la condición humana.

# 3. Introducción a la Inteligencia Artificial: Introspección

## Ensayo

### Introducción

> El juego de ajedrez, con sus complejas estrategias y movimientos específicos para cada pieza, ha inspirado una gran cantidad de problemas y desafíos interesantes. Uno de estos desafíos es el problema de intercambiar las posiciones de los alfiles negros y blancos en un tablero reducido, manteniendo la condición de que ningún alfil amenace en ningún momento a otro del color opuesto. Este problema no solo pone a prueba la habilidad táctica en el juego de ajedrez, sino que también invita a explorar estrategias creativas y métodos eficientes para lograr el intercambio deseado.

### Desarrollo

> **Problema:**
> Coloca ocho alfiles (cuatro negros y cuatro blancos) en un tablero de ajedrez reducido, tal como se ve en la figura. El problema consiste en hacer que los alfiles negros intercambien sus posiciones con los blancos, ningún alfil debe atacar en ningún momento otro del color opuesto. Se deben alternar los movimientos, primero uno blanco, luego uno negro, luego uno blanco y así sucesivamente. ¿Cuál es el mínimo número de movimientos en que se puede conseguir?.
>
> Como se explica en el problema anterior, se pide que se encuentre la solución para pasar los alfiles de un color al otro lado del tablero sin que estos puedan atacar al otro en ningún momento.
> Primeramente, se debe saber cuál es el movimiento principal del alfil para a partir de este saber que dirección debe tomar cada uno de ellos para llegar al otro lado, se sabe que estos solo pueden moverse de manera diagonal con respecto a su color de casilla, es decir, un alfil que se encuentre en una casilla negra/marrón siempre se moverá dentro de aquellas de su mismo color, y de igual forma pasa con las de color blanco/amarillo, este patrón es el mismo para el momento de atacar a otra pieza.
>
> En esta ocasión el tablero reducido nos presenta unas dimensiones de 4x5, siendo 5 el número de fila que se tiene y 4 las columnas, y dado que los alfiles están colocados a los extremos de cada una de las filas, estos nos da un margen de 3 casillas para moverse, por lo que se puede decir que el número de movimientos que se debe realizar para pasar los alfiles de un color al otro es de 3, ya que se debe mover cada uno de ellos una vez para llegar a la casilla central, y luego moverlos nuevamente para llegar a la casilla final, y así sucesivamente hasta que todos los alfiles hayan cambiado de color.
> Una vez que se ha analizado el problema y se entiende el movimiento que se debe seguir, procederemos a realizar los movimientos para llegar a la solución.
>
> Para poder visualizar de manera correcta la solución se enumeraran las filas y columnas del tablero, siendo las filas las letras de la A a la E y las columnas los números del 1 al 4, de esta manera se podrá identificar de manera más fácil la posición de cada uno de los alfiles.
>
> El tablero se vería de la siguiente manera:
> ![Tablero](/img/TableroAjedrez.png 'Tablero de ajedrez utilizado para la solución del problema')
>
> | Movimiento | Posicion inicial | Posicion final |  Color  |
> | :--------: | :--------------: | :------------: | :-----: |
> |     1      |        E2        |       D3       | Blancas |
> |     2      |        A3        |       B2       | Negras  |
> |     3      |        E1        |       B4       | Blancas |
> |     4      |        A4        |       D1       | Negras  |
> |     5      |        E3        |       D2       | Blancas |
> |     6      |        A2        |       B3       | Negras  |
> |     7      |        D3        |       B1       | Blancas |
> |     8      |        B2        |       D4       | Negras  |
> |     9      |        B4        |       A3       | Blancas |
> |     10     |        D1        |       E2       | Negras  |
> |     11     |        D2        |       C1       | Blancas |
> |     12     |        B3        |       C4       | Negras  |
> |     13     |        B1        |       C2       | Blancas |
> |     14     |        D4        |       C3       | Negras  |
> |     15     |        C1        |       E3       | Blancas |
> |     16     |        C4        |       A2       | Negras  |
> |     17     |        C2        |       A4       | Blancas |
> |     18     |        C3        |       E1       | Negras  |
> |     19     |        E4        |       C2       | Blancas |
> |     20     |        A1        |       C3       | Negras  |
> |     21     |        A3        |       C1       | Blancas |
> |     22     |        E2        |       C4       | Negras  |
> |     23     |        C2        |       D1       | Blancas |
> |     24     |        C3        |       B4       | Negras  |
> |     25     |        E3        |       D4       | Blancas |
> |     26     |        A2        |       B1       | Negras  |
> |     27     |        D4        |       A1       | Blancas |
> |     28     |        B1        |       E4       | Negras  |
> |     29     |        C1        |       B2       | Blancas |
> |     30     |        C4        |       D3       | Negras  |
> |     31     |        D1        |       B3       | Blancas |
> |     32     |        B4        |       D2       | Negras  |
> |     33     |        B2        |       A3       | Blancas |
> |     34     |        D3        |       E2       | Negras  |
> |     35     |        B3        |       A2       | Blancas |
> |     36     |        D2        |       E3       | Negras  |

### Conclusión

> Con esto se puede concluir que el número mínimo de movimientos para pasar los alfiles de un color al otro es de 36, ya que se debe mover cada uno de ellos 3 veces para llegar a la casilla central, y luego moverlos nuevamente para llegar a la casilla final, y así sucesivamente hasta que todos los alfiles hayan cambiado de color.
> Con esto nos damos cuenta de la numerosa cantidad de movimientos que se tienen que realizar para llegar a la solución, y que a pesar de que se puede llegar a la solución de manera más rápida, se debe tener en cuenta que no se puede atacar a ningún alfil del color opuesto, por lo que se debe tener cuidado con los movimientos que se realizan.

# 4. Introducción a la Inteligencia Artificial: Introspección

## Ensayo

### Introducción

> Los métodos iterativos y recursivos son dos enfoques fundamentales en programación que permiten resolver problemas de manera eficiente y elegante. Cada uno tiene sus propias características, ventajas y limitaciones, y la elección entre ellos a menudo depende de la naturaleza del problema y las preferencias del programador. En este artículo, se presentan los conceptos básicos de los métodos iterativos y recursivos, y se plantea un ejemplo aplicando ambos métodos.

### Desarrollo

> **Métodos iterativos**
> En la programación iterativa, se utiliza un bucle (por ejemplo, bucle for o while) para repetir un bloque de código hasta que se cumple una condición de salida. Este enfoque se basa en la repetición de instrucciones y es particularmente útil cuando se conoce de antemano el número de repeticiones necesarias. Los métodos iterativos suelen ser más eficientes en términos de uso de la memoria y son adecuados para resolver problemas que involucran procesos repetitivos y controlables.
>
> **Métodos recursivos**
> La programación recursiva implica la división de un problema en subproblemas más pequeños y la resolución recursiva de esos subproblemas. En lugar de usar bucles, un método recursivo invoca a sí mismo para abordar instancias más pequeñas del problema hasta llegar a un caso base que no requiere más subdivisión. Los métodos recursivos son notables por su simplicidad conceptual y la capacidad de abordar problemas complejos de manera elegante. Sin embargo, pueden ser menos eficientes en términos de uso de la memoria y pueden enfrentar problemas de desbordamiento de pila si no se manejan adecuadamente.
>
> **Diferencias**
>
> La elección entre métodos iterativos y recursivos a menudo depende de factores como la claridad del código, la naturaleza del problema y las limitaciones de rendimiento. Los métodos iterativos suelen ser preferidos en situaciones donde la eficiencia y el control preciso del flujo son cruciales, mientras que los métodos recursivos destacan en problemas que se prestan naturalmente a la subdivisión y donde la simplicidad y la elegancia son objetivos importantes.
>
> **Ejemplo**
> Se solicita un programa el cual pueda calcular el número total de islas que se encuentra dentro de un tablero de NxM dimensiones, donde cada casilla representa una isla, y se debe tener en cuenta que las islas se encuentran conectadas por las esquinas, es decir, si una isla se encuentra en la casilla A1, esta se encuentra conectada con la casilla A2 y B1, pero no con la casilla B2, ya que esta se encuentra conectada por los lados.
>
> Para este problema utilizaremos el siguiente tablero de 10x10, el cual esta configurado de la siguiente manera:
> ![Tablero](/img/TableroIslas.png 'Tablero utilizado para la solución del problema')
>
> Para la solución de este problema se utilizaran tanto el método recursivo como el iterativo, para así poder comparar los resultados obtenidos y ver cual de los dos métodos es más eficiente para la solución de este problema.
>
> **Método iterativo**
>
> > Para la solución de este problema se utilizara el método iterativo, el cual consiste en recorrer cada una de las casillas del tablero, y si esta se encuentra ocupada, se procederá a verificar si las casillas que se encuentran a su alrededor también se encuentran ocupadas, y si es así, se procederá a verificar si estas casillas se encuentran conectadas por las esquinas, y si es así, se procederá a marcarlas como visitadas, y se continuara con la siguiente casilla, y así sucesivamente hasta que se hayan recorrido todas las casillas del tablero.
> >
> > Para la solución de este problema se utilizara el siguiente código:
> >
> > ```python
> >   TABLERO = [
> >   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
> >   [0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
> >   [0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
> >   [0, 0, 0, 0, 0, 0, 0, 0, 2, 0],
> >   [0, 1, 0, 2, 2, 2, 0, 0, 2, 0],
> >   [0, 1, 0, 2, 2, 2, 0, 0, 0, 0],
> >   [0, 0, 0, 0, 2, 2, 0, 0, 0, 0],
> >   [0, 3, 3, 0, 0, 0, 2, 2, 2, 0],
> >   [0, 3, 3, 0, 0, 0, 2, 2, 0, 0],
> >   [0, 0, 0, 0, 0, 0, 2, 2, 0, 0],
> >      ]
> >
> > COLORES_ISLAS = []
> >
> > def islasIterativo(tablero, colores):
> > islas = 0
> >   for i in range(len(tablero)):
> >       for j in range(len(tablero[i])):
> >           if tablero[i][j] != 0:
> >               if tablero[i][j] not in colores:
> >                   colores.append(tablero[i][j])
> >               islas += 1
> >               eliminar_isla(tablero, i, j)
> >   return [islas, colores]
> >
> > def eliminar_isla(tablero, i, j):
> >   if i < 0 or j < 0 or i >= len(tablero) or j >= len(tablero[i]):
> >       return
> >   if tablero[i][j] == 0:
> >       return
> >   tablero[i][j] = 0
> >   eliminar_isla(tablero, i, j + 1)
> >   eliminar_isla(tablero, i, j - 1)
> >   eliminar_isla(tablero, i + 1, j)
> >   eliminar_isla(tablero, i - 1, j)
> >
> > resultado = islasIterativo(TABLERO, COLORES_ISLAS)
> > print("Hay", resultado[0], "islas")
> > print("Hay:", resultado[1].__len__(), "colores")
> > ```
> >
> > El cual nos daría como resultado lo siguiente:
> >
> > ```python
> > Hay 4 islas
> > Hay: 3 colores
> > ```
> >
> > Como se puede observar, el método iterativo nos da como resultado que hay 4 islas en el tablero, y que hay 3 colores, los cuales son el 1, 2 y 3.
>
> **Método recursivo**
>
> > Para la solución de este problema se utilizara el método recursivo, el cual consiste en recorrer cada una de las casillas del tablero, y si esta se encuentra ocupada, se procederá a verificar si las casillas que se encuentran a su alrededor también se encuentran ocupadas, y si es así, se procederá a verificar si estas casillas se encuentran conectadas por las esquinas, y si es así, se procederá a marcarlas como visitadas, y se continuara con la siguiente casilla, y así sucesivamente hasta que se hayan recorrido todas las casillas del tablero, utilizando unicamente un funcion que englobe todo el proceso.
> >
> > Para la solución de este problema se utilizara el siguiente código:
> >
> > ```python
> > TABLERO = [
> >   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
> >   [0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
> >   [0, 1, 1, 0, 0, 0, 1, 1, 0, 0],
> >   [0, 0, 0, 0, 0, 0, 0, 0, 2, 0],
> >   [0, 1, 0, 2, 2, 2, 0, 0, 2, 0],
> >   [0, 1, 0, 2, 2, 2, 0, 0, 0, 0],
> >   [0, 0, 0, 0, 2, 2, 0, 0, 0, 0],
> >   [0, 3, 3, 0, 0, 0, 2, 2, 2, 0],
> >   [0, 3, 3, 0, 0, 0, 2, 2, 0, 0],
> >   [0, 0, 0, 0, 0, 0, 2, 2, 0, 0],
> >      ]
> >
> > COLORES_ISLAS = []
> >
> > def islasRecursivo(tablero, colores):
> >
> >    def eliminar_isla(i, j):
> >        if i < 0 or j < 0 or i >= len(tablero) or j >= len(tablero[i]):
> >            return
> >        if tablero[i][j] == 0:
> >           return
> >        tablero[i][j] = 0
> >        eliminar_isla(i, j + 1)
> >        eliminar_isla(i, j - 1)
> >        eliminar_isla(i + 1, j)
> >        eliminar_isla(i - 1, j)
> >
> >    def contar_islas(i, j):
> >        if i < len(tablero):
> >            if j < len(tablero[i]):
> >                if tablero[i][j] != 0:
> >                    if tablero[i][j] not in colores:
> >                        colores.append(tablero[i][j])
> >                    eliminar_isla(i, j)
> >                    return 1 + contar_islas(i, j + 1)
> >                else:
> >                    return contar_islas(i, j + 1)
> >            else:
> >                return contar_islas(i + 1, 0)
> >        else:
> >            return 0
> >
> >    islas = contar_islas(0, 0)
> >    return [islas, colores]
> >
> >    resultado = islasRecursivo(TABLERO, COLORES_ISLAS)
> >    print("Método recursivo")
> >    print("Hay", resultado[0], "islas")
> >    print("Hay:", resultado[1].__len__(), "colores")
> > ```
> >
> > El cual nos daría como resultado lo siguiente:
> >
> > ```python
> > Método recursivo
> > Hay 4 islas
> > Hay: 3 colores
> > ```
> >
> > Como se puede observar, el método recursivo nos da como resultado que hay 4 islas en el tablero, y que hay 3 colores, los cuales son el 1, 2 y 3.

### **Conclusión**

> Como se puede observar, tanto el método iterativo como el recursivo nos dan el mismo resultado, por lo que se puede decir que ambos métodos son igual de eficientes para la solución de este problema, sin embargo, se puede decir que el método iterativo es más eficiente en cuanto al uso de memoria, ya que este solo utiliza un bucle para recorrer el tablero, mientras que el método recursivo utiliza dos funciones, una para recorrer el tablero y otra para eliminar las islas, por lo que se puede decir que el método iterativo es más eficiente que el recursivo para la solución de este problema.

# 5. Introducción a la Inteligencia Artificial: Introspección

## Ensayo

### Introducción

> La programación dinámica es una técnica de optimización que se utiliza para resolver problemas complejos dividiéndolos en subproblemas más pequeños. A diferencia de la programación recursiva, que resuelve los subproblemas de manera repetitiva, la programación dinámica resuelve cada subproblema solo una vez y almacena su solución en una tabla para su uso posterior. Este enfoque reduce drásticamente el tiempo de ejecución y la complejidad de la solución, lo que permite abordar problemas que de otro modo serían demasiado complejos para resolverlos de manera eficiente.
> En este ensayo, se presenta habla acerca de la deteccion de imagenes y como poder identificar a ciertos elementos dentro de ella.

### Desarrollo

> La visión por computadora, una rama de la inteligencia artificial, ha avanzado significativamente en las últimas décadas. Muchas de ellas nos ayudan a interactuar de cierta manera con elementos dentro del ordenador, entre las numerosas bibliotecas disponibles, OpenCV se destaca como una herramienta poderosa y versátil para el procesamiento de imágenes, el cual nos ayuda entre otras cosas a detectar objetos dentro de una imagen, asi como tener un mapeo mas profundo de la misma.
>
> **HSV**
>
> Al tener como referencia a una imagen que lleve cierto patron de colores en si misma, se puede empezar a analizar el umbral de colores en el cual caen los objetos que queremos identificar. En este caso, se utiliza OpenCV para cargar una imagen que contiene objetos de interés, presumiblemente de color rojo. La imagen se almacena como una matriz de píxeles en formato BGR, el formato convencional para las imágenes en OpenCV.
>
> Antes de adentrarnos en la detección de objetos rojos, realizamos una transformación crucial del espacio de color de la imagen de BGR a HSV (Hue-Saturation-Value). El espacio de color HSV (Hue, Saturation, Value) es una representación alternativa a RGB (Red, Green, Blue) que se utiliza comúnmente en visión por computadora y procesamiento de imágenes. A diferencia de RGB, que describe el color en términos de los componentes primarios de luz, HSV representa el color de una manera más intuitiva y cercana a cómo lo percibe el ojo humano.
>
> **Componentes de HSV:**
>
> > 1.  **Matiz (Hue):** Se refiere al tono del color, representado en un círculo de colores de 0 a 360 grados. Por ejemplo, los colores rojo, verde y azul tienen tonos específicos en este círculo.
> >
> > 2.  **Saturación (Saturation):** Indica la intensidad o pureza del color. Una saturación baja resulta en colores más apagados (grises), mientras que una saturación alta indica colores más vívidos.
> >
> > 3.  **Valor (Value o Brightness):** Representa la luminosidad del color. Un valor bajo significa un color oscuro, mientras que un valor alto indica un color más claro.
> >
> > **Umbralización y máscara:**
>
> Con la imagen en el espacio de color HSV establecido en los cuales vamos a tener nuestros objetos, establecemos umbrales para definir el rango de colores que consideraremos que cumplen con el rango de colores que estemos buscando. Estos umbrales se aplican a la imagen HSV mediante la función cv2.inRange(), generando así una máscara binaria que resalta los píxeles que cumplen con los criterios de color, dando como resultado un rango de colores que se encuentran dentro de la imagen.
>
> La máscara resultante se utiliza para identificar regiones de interés en la imagen original. La función cv2.findContours() analiza la máscara y devuelve una lista de contornos encontrados. Cada contorno es esencialmente una secuencia de puntos que forman una figura cerrada alrededor del objeto rojo detectado, los cuales son los que nos indica la cantidad de objetos que cumplen con la condicion establecida.
>
> **Análisis y Visualización:**
>
> Determinamos la cantidad de elementos (contornos) encontrados, lo que nos da una indicación de la presencia y cantidad de objetos rojos en la imagen. Este número se imprime para su referencia.
>
> Para destacar visualmente los objetos detectados, dibujamos contornos verdes alrededor de ellos en la imagen original. Esto se logra mediante la función cv2.drawContours(). Finalmente, mostramos la imagen resultante al usuario, ofreciendo una visualización de cómo se han identificado y resaltado los objetos rojos.

### **Conclusión**

> Como se puede observar, la detección de objetos dentro de una imagen es un proceso que requiere de un análisis profundo de la misma, ya que se debe tener en cuenta el espacio de color en el cual se encuentran los objetos que se quieren identificar, y a partir de esto, se debe establecer un umbral de colores para poder identificarlos, y así poder tener un mapeo de la imagen y poder identificar los objetos que se encuentran dentro de ella.

# 6. Introducción a la Inteligencia Artificial: El proceso de razonamiento según la lógica

## Planteamiento del problema

> Supongamos que hay n soldados, numerados de 1 a n, atrapados en una situación desesperada durante la guerra judeo-romana. Deciden suicidarse en lugar de ser capturados por el enemigo, pero Josephus propone un método para determinar quién será el último en quitarse la vida.
>
> Se ordena a los soldados que se coloquen en un círculo y que se cuenten en voz alta en secuencia, comenzando en el número 1, hasta que se alcance un número k; luego se elimina ese soldado y se comienza a contar nuevamente desde el siguiente soldado. El proceso continúa hasta que solo queda un soldado, que es el que se salva.
>
> Por ejemplo, supongamos que hay 5 soldados y k = 2. Los soldados se numeran de 1 a 5 y se colocan en un círculo. Se cuentan en voz alta en secuencia, comenzando en el número 1, hasta que se alcanza el número 2; luego se elimina el soldado número 2 y se comienza a contar nuevamente desde el siguiente soldado.
>
> Josephus siempre se sienta en la posición 2^m+1, donde m es el exponente más grande de 2 que es menor o igual a n. Esto se debe a que, siguiendo las reglas de eliminación, después de 2^m pasos, se elimina un soldado y el siguiente soldado en ser eliminado es el que está en la posición 2^m+1.
>
> La estrategia óptima para Josephus es identificar el exponente m y sentarse en la posición 2^m+1, garantizando así que sea el último sobreviviente en esta situación extrema.

![Josephus](/img/Josephus.jpg 'Problema de Josephus')

## Solución

> Para la solución de este problema se utilizara el siguiente código:

```python
# Problema de Josephus
def josephus(asientos, saltos):
    saltos -= 1
    soldado = saltos
    while len(asientos) > 1:
        print('Murio: ',asientos.pop(soldado))
        soldado = (soldado + saltos) % len(asientos)
    print('survivor: ', asientos[0])

josephus([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,30,31,32,33,34,35,36,37,38,39,40,41], 2)
```

## Conclusión

> Como se puede observar, la solución de este problema es bastante sencilla, ya que solo se debe tener en cuenta el número de asientos y el número de saltos que se van a realizar, y a partir de esto, se procede a eliminar a los soldados que se encuentran en la posición de los saltos, hasta que solo quede un soldado, el cual será el sobreviviente.

# 7. Introducción a la Inteligencia Artificial: El papel de la heurística

> La heurística es un enfoque o método de resolución de problemas que se basa en reglas prácticas, experiencias previas o intuiciones para encontrar soluciones rápidas y eficientes, aunque no necesariamente garantizan la solución óptima. En lugar de seguir un enfoque algorítmico riguroso, las heurísticas buscan estrategias que, en la mayoría de los casos, conducen a soluciones aceptables o satisfactorias.
>
> Papel en la Resolución de Problemas:
>
> > 1.  **Eficiencia:**
> >     Las heurísticas son especialmente útiles en problemas complejos donde la búsqueda exhaustiva de soluciones óptimas podría ser computacionalmente costosa o prácticamente imposible debido al tamaño del espacio de búsqueda.
> >     Permiten encontrar soluciones en un tiempo razonable al sacrificar la garantía de optimización.
> >
> > 2.  **Exploración del espacio de soluciones:**
> >     En lugar de explorar cada posibilidad de manera exhaustiva, las heurísticas guían la búsqueda hacia áreas más prometedoras del espacio de soluciones.
> >     Esto es crucial en problemas con un gran número de posibles soluciones, ya que ayuda a reducir la complejidad computacional.
> >
> > 3.  **Adaptabilidad:**
> >     Las heurísticas son flexibles y pueden adaptarse a diferentes tipos de problemas y contextos.
> >     Pueden ser ajustadas o modificadas según la naturaleza específica de un problema.
> >
> > 4.  **Toma de decisiones rápida:**
> >     En situaciones donde se requiere una toma de decisiones rápida y no hay tiempo para una análisis exhaustivo, las heurísticas ofrecen una solución práctica y rápida.
> >
> > 5.  **Soluciones aceptables:**
> >     Aunque no garantizan la mejor solución posible, las heurísticas tienden a generar soluciones aceptables y satisfactorias en la mayoría de los casos.
> >     Son particularmente útiles en entornos donde se valora la eficiencia y la toma de decisiones práctica.
> >
> > 6.  **Aplicación en problemas del mundo real:**
> >     En muchos problemas del mundo real, donde las condiciones y restricciones pueden cambiar rápidamente, las heurísticas permiten tomar decisiones informadas sin la necesidad de recalcular constantemente.
> >
> > 7.  **Creatividad y innovación:**
> >     La aplicación de heurísticas a menudo involucra la aplicación creativa de reglas y estrategias, lo que puede llevar a la innovación en la resolución de problemas.

> ## Problema
>
> > Realizar un algoritmo que permita recorrer todo un laberinto hasta llegar a la salida, teniendo en cuenta que el laberinto puede tener caminos cerrados, y que el algoritmo debe encontrar la salida de manera rápida y eficiente.

> ## Solución
>
> > Para la solución de este problema se utilizara el siguiente código:
> >
> > ```python
> > # Laberinto
> > laberinto = [
> >     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
> >     [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
> >     [1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
> >     [1, 0, 1, 0, 0, 0, 0, 0, 0, 1],
> >     [1, 0, 1, 0, 1, 1, 1, 1, 1, 1],
> >     [1, 0, 1, 0, 1, 0, 0, 0, 0, 1],
> >     [1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
> >     [1, 0, 1, 0, 1, 0, 1, 0, 0, 1],
> >     [1, 0, 0, 0, 1, 0, 1, 3, 0, 1],
> >     [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
> > ]
> >
> > def resolver_laberinto(laberinto, fila, columna):
> >         if fila < 0 or columna < 0 or fila >= len(laberinto) or columna >= len(laberinto>>[0]):
> >            return False
> >        if laberinto[fila][columna] == 3:
> >            return True
> >        if laberinto[fila][columna] == 1 or laberinto[fila][columna] == 4:
> >            return False
> >        laberinto[fila][columna] = 4
> >        if (resolver_laberinto(laberinto, fila + 1, columna) or
> >            resolver_laberinto(laberinto, fila - 1, columna) or
> >            resolver_laberinto(laberinto, fila, columna + 1) or
> >            resolver_laberinto(laberinto, fila, columna - 1)):
> >            return True
> >        laberinto[fila][columna] = 0
> >        return False
> >    for i in range(len(laberinto)):
> >        for j in range(len(laberinto[0])):
> >            if laberinto[i][j] == 2:
> >                inicio_fila, inicio_columna = i, j
> >    if resolver_laberinto(laberinto, inicio_fila, inicio_columna):
> >        print("Se encontró una solución. El laberinto resuelto es:")
> >        for fila in laberinto:
> >            print(fila)
> >    else:
> >        print("No hay solución para el laberinto.")
> >
> > resolver_laberinto(laberinto, 7, 0)
> > ```
> >
> > **Explica el funcionamiento del algoritmo**
>
> En el codigo anterior se verifica constantemente que la casilla a la cual se esta intentanto acceder sea valida, es decir, que no se encuentre fuera de los limites del laberinto, que no sea una pared, y que no se haya visitado anteriormente, y si se cumple con estas condiciones, se procede a marcar la casilla como visitada, y se procede a verificar si la casilla es la salida, y si es asi, se procede a imprimir el laberinto resuelto, y si no es asi, se procede a verificar si se puede acceder a las casillas adyacentes, y si se puede, se procede a verificar si estas casillas son la salida, y si no lo son, se procede a marcarlas como visitadas, y se continua con el proceso hasta que se encuentre la salida, o hasta que no se pueda acceder a ninguna casilla, y si no se encuentra la salida, se imprime que no se encontro una solucion para el laberinto.

# 8. Reglas y Búsquedas : Espacio de Estados

> 1. El juego consiste en pasar las 3 ranas verdes a la derecha y las 3 ranas marrones a la izquierda. Las ranas pueden saltar a una piedra vacía que tengan delante, o saltar por encima de otra rana si en medio de ambas hay una piedra vacía. Pulsa sobre la rana que quieres que salte.
>    ![Ranas](/img/Ranas.png 'Problema de las ranas')
>
> ## Solución
>
> > 1.  | 🟢  | 🟢  | 🟢  | 🔳  | 🟤  | 🟤  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 2.  | 🟢  | 🟢  | 🔳  | 🟢  | 🟤  | 🟤  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 3.  | 🟢  | 🟢  | 🟤  | 🟢  | 🔳  | 🟤  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 4.  | 🟢  | 🟢  | 🟤  | 🟢  | 🟤  | 🔳  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 5.  | 🟢  | 🟢  | 🟤  | 🔳  | 🟤  | 🟢  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 6.  | 🟢  | 🔳  | 🟤  | 🟢  | 🟤  | 🟢  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 7.  | 🔳  | 🟢  | 🟤  | 🟢  | 🟤  | 🟢  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 8.  | 🟤  | 🟢  | 🔳  | 🟢  | 🟤  | 🟢  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 9.  | 🟤  | 🟢  | 🟤  | 🟢  | 🔳  | 🟢  | 🟤  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 10. | 🟤  | 🟢  | 🟤  | 🟢  | 🟤  | 🟢  | 🔳  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 11. | 🟤  | 🟢  | 🟤  | 🟢  | 🟤  | 🔳  | 🟢  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 12. | 🟤  | 🟢  | 🟤  | 🔳  | 🟤  | 🟢  | 🟢  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 13. | 🟤  | 🔳  | 🟤  | 🟢  | 🟤  | 🟢  | 🟢  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 14. | 🟤  | 🟤  | 🔳  | 🟢  | 🟤  | 🟢  | 🟢  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 15. | 🟤  | 🟤  | 🟤  | 🟢  | 🔳  | 🟢  | 🟢  |
> >     | --- | --- | --- | --- | --- | --- | --- |
> > 16. | 🟤  | 🟤  | 🟤  | 🔳  | 🟢  | 🟢  | 🟢  |
> >     | --- | --- | --- | --- | --- | --- | --- |
>
> 2. Tres misioneros se perdieron explorando una jungla. Separados de sus compañeros, sin alimento y sin radio, solo sabían que para llegar a su destino debían ir siempre hacia adelante. Los tres misioneros se detuvieron frente a un río que les bloqueaba el paso, preguntándose que podían hacer. De repente, aparecieron tres caníbales llevando un bote, pues también ellos querían cruzar el río. Ya anteriormente se habían encontrado grupos de misioneros y caníbales, y cada uno respetaba a los otros, pero sin confiar en ellos. Los caníbales se daban un festín con los misioneros cuando les superaban en número. Los tres caníbales deseaban ayudar a los misioneros a cruzar el río, pero su bote no podía llevar más de dos personas a la vez y los misioneros no querían que los caníbales les superaran en número. ¿Cómo puede resolverse el problema, sin que en ningún momento haya más caníbales que misioneros en cualquier orilla del río? recuerda que un misionero y un caníbal en una orilla del río más uno o dos caníbales en el bote al mismo lado, significa que los misioneros tendrán problemas.
>    ![Misioneros](/img/Misioneros.png 'Problema de los misioneros')
>
> ## Solución
>
> 🟤 = Canival
> ⚫ = Misionero
>
> > 1.  | ⚫ ⚫ ⚫ 🟤 🟤 🟤 🛶 | 🌊  |     |
> >     | -------------------- | --- | --- |
> > 2.  | ⚫ ⚫ ⚫ 🟤 | 🌊  | 🛶 🟤 🟤 |
> >     | ----------- | --- | -------- |
> > 3.  | ⚫ ⚫ ⚫ 🟤🟤🛶 | 🌊  | 🟤  |
> >     | --------------- | --- | --- |
> > 4.  | ⚫ ⚫ ⚫ | 🌊  | 🛶 🟤 🟤🟤 |
> >     | -------- | --- | ---------- |
> > 5.  | ⚫ ⚫ ⚫🟤🛶 | 🌊  | 🟤🟤 |
> >     | ------------ | --- | ---- |
> > 6.  | ⚫🟤 | 🌊  | 🛶 🟤🟤⚫ ⚫ |
> >     | ---- | --- | ------------ |
> > 7.  | ⚫🟤🟤⚫🛶 | 🌊  | 🟤 ⚫ |
> >     | ---------- | --- | ----- |
> > 8.  | 🟤🟤 | 🌊  | 🟤 ⚫⚫ ⚫🛶 |
> >     | ---- | --- | ------------ |
> > 9.  | 🟤🟤🟤 🛶 | 🌊  | ⚫⚫ ⚫ |
> >     | --------- | --- | ------- |
> > 10. | 🟤  | 🌊  | 🟤🟤 🛶 ⚫⚫ ⚫ |
> >     | --- | --- | --------------- |
> > 11. | 🟤 🟤 🛶 | 🌊  | 🟤 ⚫⚫ ⚫ |
> >     | -------- | --- | ---------- |
> > 12. |     | 🌊  | 🟤 🟤 🛶🟤 ⚫⚫ ⚫ |
> >     | --- | --- | ------------------ |

# 9. Generación de Dataset

> Generar un dataset de rostros por lo menos 5 diferentes, y entrenar un modelo de reconocimiento de rostros con el dataset generado.
>
> ## Cascade
>
> > ```python
> > #Tomar fotos para el dataset, presionar s para guardar la imagen
> > import numpy as np
> > import cv2 as cv
> > import math
> >
> > cap = cv.VideoCapture(0)
> > i=0
> > while True:
> >    ret, frame = cap.read()
> >
> > frame = cv.rectangle(frame, (100,100), (400, 400), (255,0,0), 1)
> > frame2 = frame[100:400, 100:400]
> > frame4 = cv.resize(frame, (1050,1630))
> > frame5 = cv.resize(frame2, (780,540), interpolation= cv.INTER_LINEAR)
> > cv.imshow('frame', frame)
> > cv.imshow('dataset', frame2)
> > k = cv.waitKey(1)
> > if k == ord('p'):
> >     i=i+1
> >     cv.imwrite('D:/Descargas/Fotos/p/'+str(i)+'new.jpg', frame2)
> > if k == ord('n'):
> >     i=i+1
> >     cv.imwrite('D:/Descargas/Fotos/n/'+str(i)+'new.jpg', frame2)
> > if k == 27:
> >     break
> > cap.release()
> > cv.destroyAllWindows()
> > ```
> >
> > ```python
> > #Programa para ejecutar el cascade generado
> > import numpy as np
> > import cv2 as cv
> >
> > rostro = cv.CascadeClassifier('./cascade3.xml')
> >
> > cap = cv.VideoCapture(0)
> > x=y=w=h= 0
> > img = 0
> > count = 0
> > while True:
> >     ret, frame = cap.read()
> >     gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)
> >     rostros = rostro.detectMultiScale(gray, 1.5, 30)
> >     for(x, y, w, h) in rostros:
> >         m= int(h/2)
> >         frame = cv.rectangle(frame, (x,y), (x+w, y+h), (0, 255, 0), 2)
> >
> >     cv.imshow('rostros', frame)
> >
> >     k = cv.waitKey(1)
> >     if k == 27:
> >         break
> > cap.release()
> > cv.destroyAllWindows()
> > ```
>
> ## Phaser
>
> > ```JavaScript
> > //Programa para ejecutar el Phaser
> > var w=800;
> > var h=400;
> > var jugador;
> > var fondo;
> > var newGame = true;
> >
> > var bala, balaD=false, nave;
> > var bala2, balaD2 = false, nave2;
> > //Direccion 1=izquierda 2=derecha
> > var salto, izquierda, derecha, direccion = 1;
> > var menu;
> >
> > var velocidadBala;
> > var despBala;
> > var velocidadBala2 = 203;
> > var despBala2;
> > var despBala2x;
> > var estatusAire;
> > var estatuSuelo;
> > var avanzo;
> > var quieto;
> > var nnNetwork2 , nnEntrenamiento2, nnSalida2, datosEntrenamiento2=[];
> > var nnNetwork , nnEntrenamiento, nnSalida, datosEntrenamiento=[];
> > var modoAuto = false, eCompleto=false;
> >
> >
> >
> > var juego = new Phaser.Game(w, h, Phaser.CANVAS, '', { preload: preload, create: create, update: update, render:render});
> >
> > function preload() {
> >    juego.load.image('fondo', 'assets/game/fondo.jpg');
> >    juego.load.spritesheet('mono', 'assets/sprites/altair.png',32 ,48);
> >    juego.load.image('nave', 'assets/game/ufo.png');
> >    juego.load.image('bala', 'assets/sprites/purple_ball.png');
> >    juego.load.image('menu', 'assets/game/menu.png');
> >
> > }
> >
> > function create() {
> >
> >    juego.physics.startSystem(Phaser.Physics.ARCADE);
> >    juego.physics.arcade.gravity.y = 800;
> >    juego.time.desiredFps = 30;
> >
> >    fondo = juego.add.tileSprite(0, 0, w, h, 'fondo');
> >    nave = juego.add.sprite(w-100, h-70, 'nave');
> >    nave2 = juego.add.sprite(20, h-400, 'nave');
> >    bala = juego.add.sprite(w-100, h, 'bala');
> >    bala2 = juego.add.sprite(55, h-350, 'bala');
> >    jugador = juego.add.sprite(50, h, 'mono');
> >
> >
> >    juego.physics.enable(jugador);
> >    jugador.body.collideWorldBounds = true;
> >    var corre = jugador.animations.add('corre',[8,9,10,11]);
> >    jugador.animations.play('corre', 10, true);
> >
> >    juego.physics.enable(bala);
> >    bala.body.collideWorldBounds = true;
> >
> >    juego.physics.enable(bala2);
> >    bala2.body.collideWorldBounds = true;
> >
> >    pausaL = juego.add.text(w - 100, 20, 'Pausa', { font: '20px Arial', fill: '#fff' });
> >    pausaL.inputEnabled = true;
> >    pausaL.events.onInputUp.add(pausa, self);
> >    juego.input.onDown.add(mPausa, self);
> >
> >    salto = juego.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
> >    izquierda = juego.input.keyboard.addKey(Phaser.Keyboard.A)
> >    derecha = juego.input.keyboard.addKey(Phaser.Keyboard.D)
> >
> >    nnNetwork =  new synaptic.Architect.Perceptron(2, 6, 6, 2);
> >     nnEntrenamiento = new synaptic.Trainer(nnNetwork);
> >
> >     nnNetwork2 =  new synaptic.Architect.Perceptron(2, 6, 6, 2);
> >     nnEntrenamiento2 = new synaptic.Trainer(nnNetwork2);
> >
> > }
> >
> > function enRedNeural(){
> >     nnEntrenamiento.train(datosEntrenamiento, {rate: 0.0003, iterations: 10000, shuffle: true});
> > }
> >
> > function redNeuronalAvanzar(){
> >     nnEntrenamiento2.train(datosEntrenamiento2, {rate: 0.0003, iterations: 10000, shuffle: true});
> > }
> >
> > function datosDeEntrenamiento(param_entrada){
> >
> >     // console.log("Entrada",param_entrada[0]+" "+param_entrada[1]);
> >     nnSalida = nnNetwork.activate(param_entrada);
> >     var aire=Math.round( nnSalida[0]*100 );
> >     var piso=Math.round( nnSalida[1]*100 );
> >     // console.log("Valor ","En el Aire %: "+ aire + " En el suelo %: " + piso );
> >     return nnSalida[0]>=nnSalida[1];
> > }
> >
> > function datosDeEntrenamientoBala2(param_entrada){
> >     // console.log("Entrada2",param_entrada[0]);
> >     nnSalida2 = nnNetwork2.activate(param_entrada);
> >     var avanzo=Math.round( nnSalida2[0]*100 );
> >     var quieto=Math.round( nnSalida2[1]*100 );
> >     // console.log("Valor ","Avanzo %: "+ avanzo + " Quietos %: " + quieto );
> >     return nnSalida2[0] >= nnSalida2[1];
> > }
> >
> >
> >
> > function pausa(){
> >     juego.paused = true;
> >     menu = juego.add.sprite(w/2,h/2, 'menu');
> >     menu.anchor.setTo(0.5, 0.5);
> > }
> >
> > function mPausa(event){
> >     if(juego.paused){
> >         var menu_x1 = w/2 - 270/2, menu_x2 = w/2 + 270/2,
> >             menu_y1 = h/2 - 180/2, menu_y2 = h/2 + 180/2;
> >
> >         var mouse_x = event.x  ,
> >             mouse_y = event.y  ;
> >
> >         if(mouse_x > menu_x1 && mouse_x < menu_x2 && mouse_y > menu_y1 && mouse_y < menu_y2 ){
> >             if(mouse_x >=menu_x1 && mouse_x <=menu_x2 && mouse_y >=menu_y1 && mouse_y <=menu_y1+90){
> >                 eCompleto=false;
> >                 datosEntrenamiento = [];
> >                 datosEntrenamiento2 = [];
> >                 modoAuto = false;
> >                 newGame = true;
> >             }else if (mouse_x >=menu_x1 && mouse_x <=menu_x2 && mouse_y >=menu_y1+90 && mouse_y <=menu_y2) {
> >                 newGame = true;
> >                 if(!eCompleto) {
> >                     console.log('entrenamiento: ', datosEntrenamiento.length)
> >                     console.log('entrenamiento2: ', datosEntrenamiento2.length)
> >                     enRedNeural();
> >                     redNeuronalAvanzar();
> >                     eCompleto=true;
> >                 }
> >                 modoAuto = true;
> >             }
> >
> >             menu.destroy();
> >             resetVariables();
> >             juego.paused = false;
> >
> >         }
> >     }
> > }
> >
> >
> > function resetVariables(){
> >     jugador.body.velocity.x=0;
> >     jugador.body.velocity.y=0;
> >     jugador.body.position.x = 50;
> >
> >     bala.body.velocity.x = 0;
> >     bala.position.x = w-100;
> >
> >     bala2.body.velocity.y = velocidadBala2;
> >     bala2.position.y = h-350;
> >     // bala2.body.velocity.y = velocidadBala2;
> >     // bala2.position.y = h-350;
> >     // bala2.position.x = jugador.position.x + Math.random(-1, 1);
> >     balaD2=false;
> >     balaD=false;
> >     // balaD2=false;
> > }
> >
> > function saltar(){
> >     jugador.body.velocity.y = -270;
> > }
> >
> > function moverDerecha(){
> >     if( jugador.body.position.x < 100)
> >         jugador.body.position.x += 10;
> > }
> >
> > function moverDerecha2(){
> >
> >     if( jugador.body.position.x < 100)
> >         jugador.body.position.x += 20;
> > }
> >
> >
> > function update() {
> >
> >     if(newGame){
> >         newGame = false;
> >         jugador.body.position.x = 50;
> >         nave2.position.x = 50;
> >         bala2.position.x = 50;
> >         bala2.position.y = h-350;
> >     }
> >
> >     fondo.tilePosition.x -= 1;
> >
> >     juego.physics.arcade.collide(bala, jugador, colisionH, null, this);
> >     juego.physics.arcade.collide(bala2, jugador, colisionH, null, this);
> >
> >     estatuSuelo = 1;
> >     estatusAire = 0;
> >     avanzo = 0;
> >     quieto = 1;
> >
> >     if(!jugador.body.onFloor()) {
> >         estatuSuelo = 0;
> >         estatusAire = 1;
> >     }
> >     if( jugador.body.position.x > 50){
> >         avanzo = 1;
> >         quieto = 0;
> >     }
> > 	bala2.body.velocity.y = velocidadBala2;
> >     despBala = Math.floor( jugador.position.x - bala.position.x );
> >     //Devuelve cuanto falta para que la bala impacte al jugador
> >     despBala2 = Math.floor( jugador.position.y - bala2.position.y );
> >     despBala2x = Math.floor( jugador.position.x - bala2.position.x );
> >
> >     if( modoAuto==false && derecha.isDown &&  jugador.body.onFloor() ){
> >         moverDerecha();
> >     }
> >
> >     if( modoAuto==false && salto.isDown &&  jugador.body.onFloor() ){
> >         saltar();
> >     }
> >
> >     if( modoAuto == true  && bala.position.x>0 && jugador.body.onFloor()) {
> >
> >         if( datosDeEntrenamientoBala2( [despBala2, velocidadBala2] )  ){
> >             if(despBala2x === 0)
> >                moverDerecha2();
> >         }
> >
> >         if( datosDeEntrenamiento( [despBala , velocidadBala] ) ){
> >             if(despBala2x === 0 && despBala2 > 150)
> >                 saltar();
> >             else if(despBala2x > 0)
> >                 saltar();
> >         }
> >     }
> >
> >     if( balaD==false ){
> >         disparo();
> >     }
> >
> >     if( bala.position.x <= 0  ){
> >         resetVariables();
> >     }
> >
> >     if( balaD2==false ){
> >         disparo2();
> >     }
> >
> >     if( modoAuto ==false  && bala.position.x > 0 ){
> >
> >         datosEntrenamiento.push({
> >                 'input' :  [despBala , velocidadBala],
> >                 'output':  [estatusAire , estatuSuelo]
> >         });
> >    }
> >
> >    if( modoAuto == false && bala2.position.y > 50 ){
> >         datosEntrenamiento2.push({
> >                 'input' :  [despBala2, velocidadBala2],
> >                 'output':  [avanzo, quieto]
> >         });
> >    }
> > }
> >
> >
> > function disparo(){
> >     velocidadBala =  -1 * velocidadRandom(300,400);
> >     bala.body.velocity.y = 0 ;
> >     bala.body.velocity.x = velocidadBala ;
> >    balaD=true;
> >    balaD2=true;
> > }
> >
> > function disparo2(){
> >    bala2.body.velocity.y = velocidadBala2;
> >    balaD2=true;
> > }
> >
> > function colisionH(){
> >    pausa();
> > }
> >
> > function velocidadRandom(min, max) {
> >    return Math.floor(Math.random() * (max - min + 1)) + min;
> > }
> >
> > function render(){
> >
> > }
> >
> > ```
>
> ## CNN
>
> Dataset creado para identificar y clasificar a flores de tipo Astilbe, Iris, Rosa, Girasol y Tulipan.
> ![CNN](/img/CNN_1.png 'CNN') ![CNN](/img/CNN_2.png 'CNN') ![CNN](/img/CNN_3.png 'CNN') ![CNN](/img/CNN_4.png 'CNN')
> Programa para ejecutar el modelo entrenado
>
> > ```python
> > from matplotlib import pyplot as plt
> > from skimage.transform import resize
> > import tensorflow as tf
> > from tensorflow.keras.preprocessing import image
> > import numpy as np
> >
> > modelpath = './Flores.h5py'
> > model = tf.keras.models.load_model(modelpath)
> >
> > target_size = (28, 28)
> > img_path = './Tulipan.jpg'
> >
> > # Load and resize the image
> > img = image.load_img(img_path, target_size=target_size)
> > img_array = image.img_to_array(img)
> > img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension
> >
> > # Normalize pixel values to be between 0 and 1
> > img_array /= 255.0
> >
> > # Make predictions
> > predictions = model.predict(img_array)
> > class_names = ['astilbe', 'iris', 'roses', 'sunflowers', 'tulip']
> >
> > predicted_class = np.argmax(predictions, axis=1)
> > predicted_label = class_names[predicted_class[0]]
> >
> > # Display the image and predicted label
> > plt.imshow(img)
> > plt.title(f'Predicted Label: {predicted_label}')
> > plt.show()
> >
> > ```
